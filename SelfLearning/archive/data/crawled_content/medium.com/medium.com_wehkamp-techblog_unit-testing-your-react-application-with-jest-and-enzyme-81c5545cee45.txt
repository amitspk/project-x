=== METADATA ===
Title: Unit testing your React application with Jest and Enzyme | by Berry de Witte | wehkamp-techblog | Medium
Description: Unit testing your React application with Jest and Enzyme I don‚Äôt think i have to tell you the importance of unit testing your code, so i‚Äôll dive in directly to unit testing with Jest and ‚Ä¶
Author: Berry de Witte
Og_Title: Unit testing your React application with Jest and Enzyme
Og_Description: I don‚Äôt think i have to tell you the importance of unit testing your code, so i‚Äôll dive in directly to unit testing with Jest and Enzyme.
Canonical_Url: https://medium.com/wehkamp-techblog/unit-testing-your-react-application-with-jest-and-enzyme-81c5545cee45
Language: en
Charset: utf-8
====================

=== MAIN ARTICLE CONTENT ===
Unit testing your React application with Jest and Enzyme
Berry de Witte
5 min read
¬∑
Aug 16, 2017
--
7
Listen
Share
I don‚Äôt think i have to tell you the importance of unit testing your code, so i‚Äôll dive in directly to unit testing with Jest and Enzyme.
First of all what are Jest and Enzyme?
Jest
was created by Facebook and is a testing framework to test javascript and React code. Together with Airbnb‚Äôs
Enzyme
, which is a testing utility, makes it the perfect match to easily test your React application.
Snapshots to the rescue
Let‚Äôs start off easy with testing a simple pure stateless (a.k.a. dumb) component which renders a simple link element containing a title and an url.
import React from 'react';
import { string } from 'prop-types';
const Link = ({ title, url }) => <a href={url}>{title}</a>;
Link.propTypes = {
title: string.isRequired,
url: string.isRequired
};
export default Link;
We want to test this component by checking if the properties are coming in right and if it‚Äôs rendered correctly. With Jest we have a very easy way to do this by creating snapshots. The first time when running the test a snapshot is created. You can then look at the created file to check whether this rendered component matches your desired outcome. Let‚Äôs write the first test for our component. In this case we‚Äôre gonna use the
shallow
renderer of Enzyme to help us creating the snapshot.
import React from 'react';
import { shallow } from 'enzyme';
import { shallowToJson } from 'enzyme-to-json';
import Link from './Link';
describe('Link', () => {
it('should render correctly', () => {
const output = shallow(
<Link title="mockTitle" url="mockUrl" />
);
expect(shallowToJson(output)).toMatchSnapshot();
});
});
After running the tests, Jest will automaticly create a
__snapshots__
directory and a snapshot file containing the outcome of the test. In this case it creates a
Link-spec.js.snap
file containing the following outcome of the rendering of our component.
// Jest Snapshot v1,
https://goo.gl/fbAQLP
exports[`Link should render correctly 1`] = `
<a
href="mockUrl"
>
mockTitle
</a>
`;
Simulating events
Let‚Äôs upgrade our component by adding a click event. This also means we have to rewrite our component to the class notation as we are going to bind the click event function to the component. Which can easily be done by creating an arrow function inside our component.
import React, { Component } from 'react';
import { string } from 'prop-types';
class Link extends Component {
handleClick() => {
alert('clicked!');
};
render() {
const { title, url } = this.props;
return <a href={url} onClick={this.handleClick}>{title}</a>;
}
}
When you run our previous test at this moment, it will fail as your saved snapshot doesn‚Äôt match the new snapshot because we added the onClick property. If the snapshot looks correctly, you can easily update it by pressing
u.
The snapshot will now look like:
exports[`Link should render correctly 1`] = `
<a
href="mockUrl"
onClick={[Function]}
target=""
>
mockTitle
</a>
`;
We are going to create a second test case to check whether the onClick event is being handled correctly. Our click events triggers an alert and we can easily mock this functionality in Jest by using
jest.fn()
. After shallow rendering our component we‚Äôre simulating a click event and check if the alert is being called with the correct string. (In this case no snapshot file is created, as we don‚Äôt use the snapshot functionality)
it('should handle the click event', () => {
window.alert = jest.fn();
const output = shallow(
<Link title="mockTitle" url="mockUrl" />
);
output.simulate('click');
expect(window.alert).toHaveBeenCalledWith('clicked');
});
Testing the state
We can also easily test the state of our component. Update the component by initiating the state in the constructor and expanding the click event with the setState function. When clicking on the element, we‚Äôre now also going to update the clicked state from false to true.
class Link extends Component {
constructor(props) {
super(props);
this.state = { clicked: false };
}
handleClick = () => {
alert('clicked');
this.setState({ clicked: true });
}
...
}
Let‚Äôs create a third test where we render the output and check the state. The first time we check the clicked state property should be false. After a click the property should be changed to true.
it('should handle state changes', () => {
const output = shallow(
<Link title="mockTitle" url="mockUrl" />
);
expect(output.state().clicked).toEqual(false);
output.simulate('click');
expect(output.state().clicked).toEqual(true);
});
The art of mocking
One of the best benefits of Jest is the easiness of creating all kind of mocks. We already used
jest.fn()
in one of our unit tests which is a very simple mock function that returns a spy, but you can also mock entire files.
If you aren‚Äôt mocking, you aren‚Äôt unit testing!
The most easiest way to mock files is using the
jest.mock
function which automatically mocks the file by returning mocked functions. Let try to mock
react-dom
and check whether the render function has been called.
import React from 'react';
import { render } from 'react-dom';
import Link from './Link';
jest.mock('react-dom');
describe('Link', () => {
it('should render correctly', () => {
expect(render).toHaveBeenCalledWith(
<Link title="mockTitle" url="mockUrl" />, 'element-node'
);
expect(render).toHaveBeenCalledTimes(1);
});
});
We create the test like we normally would do, but added the
jest.mock
line. Now the
render
function of
react-dom
is a mock function which returns a spy which we can now use in our test to check whether it has been called with the correct properties.
When you don‚Äôt want Jest to automatically create mock functions of your file, you can easily create a mock file yourself. Just create a
__mocks_
_ directory and add the to be mocked file in there. Now Jest will use this file when you call
jest.mock
in your unit test. For the react-dom example, create react-dom.js file which returns the render spy function.
export default {
render: jest.fn(),
};
In our example we‚Äôre returning a spy function on which we can check whether it‚Äôs called correctly, but you‚Äôre spy could also return values or implementations.
render: jest.fn().mockReturnValue('component is rendered'),
render: jest.fn().mockImplementation(() => 'mock implementation'),
Roundup
So these are the very basics of unit testing your application using Jest and Enzyme. Both have very good online documentation available, start from here and you can create your unit tests in a fast, efficient and easy way!
There‚Äôs no reason to not start testing today ;)
Thank you for taking the time to reading this story! If you enjoyed reading this story, click the üëèüèª below so other people will see this here on Medium.
Also, I work at
wehkamp.nl
one of the biggest e-commerce companies of the Netherlands. We do have a
tech blog
, check it out and subscribe if you want to read more stories like this one. Or look at our
job offers
if you are looking for a great job!

=== HEADLINES ===
## wehkamp-techblog
   [DOM: h2, classes: bg, gw, gx, ef, gy, gz, eh, ha, hb, hc, hd, he, hf, hg, hh, hi, hj, bl]
# Unit testing your React application with Jest and Enzyme
   [DOM: h1, classes: pw-post-title, iz, ja, jb, bg, jc, jd, je, jf, jg, jh, ji, jj, jk, jl, jm, jn, jo, jp, jq, jr, js, jt, ju, jv, jw, jx, jy, jz, ka, kb, bl]
## Published inwehkamp-techblog
   [DOM: h2, classes: pw-author-name, bg, gw, sp, sq, sr, ss, st, su, hb, hc, hd, he, hf, hg, hh, hi, hj, bl]
## Written byBerry de Witte
   [DOM: h2, classes: pw-author-name, bg, gw, sp, sq, sr, ss, st, su, hb, hc, hd, he, hf, hg, hh, hi, hj, bl]
## Responses (7)
   [DOM: h2, classes: bg, gw, tb, tc, gy, td, te, ha, tf, tg, th, ti, tj, tk, tl, tm, tn, bl]

=== CONTENT PARAGRAPHS ===
[Paragraph 1] (20 words)
   [DOM: p.bg.b.bh.ab.eb, parent: div]
   We'll try to keep up and post on the stuff we're doing and discovering. Interesting in working @wehkamp? Check outhttps://werkenbij.wehkamp.nl/

[Paragraph 2] (27 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   I don‚Äôt think i have to tell you the importance of unit testing your code, so i‚Äôll dive in directly to unit testing with Jest and Enzyme.

[Paragraph 3] (41 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   First of all what are Jest and Enzyme?Jestwas created by Facebook and is a testing framework to test javascript and React code. Together with Airbnb‚ÄôsEnzyme, which is a testing utility, makes it the perfect match to easily test your React application.

[Paragraph 4] (28 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   Snapshots to the rescueLet‚Äôs start off easy with testing a simple pure stateless (a.k.a. dumb) component which renders a simple link element containing a title and an url.

[Paragraph 5] (86 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   We want to test this component by checking if the properties are coming in right and if it‚Äôs rendered correctly. With Jest we have a very easy way to do this by creating snapshots. The first time when running the test a snapshot is created. You can then look at the created file to check whether this rendered component matches your desired outcome. Let‚Äôs write the first test for our component. In this case we‚Äôre gonna use theshallowrenderer of Enzyme to help us creating the snapshot.

[Paragraph 6] (35 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   After running the tests, Jest will automaticly create a__snapshots__directory and a snapshot file containing the outcome of the test. In this case it creates aLink-spec.js.snapfile containing the following outcome of the rendering of our component.

[Paragraph 7] (49 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   Simulating eventsLet‚Äôs upgrade our component by adding a click event. This also means we have to rewrite our component to the class notation as we are going to bind the click event function to the component. Which can easily be done by creating an arrow function inside our component.

[Paragraph 8] (44 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   When you run our previous test at this moment, it will fail as your saved snapshot doesn‚Äôt match the new snapshot because we added the onClick property. If the snapshot looks correctly, you can easily update it by pressingu.The snapshot will now look like:

[Paragraph 9] (73 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   We are going to create a second test case to check whether the onClick event is being handled correctly. Our click events triggers an alert and we can easily mock this functionality in Jest by usingjest.fn(). After shallow rendering our component we‚Äôre simulating a click event and check if the alert is being called with the correct string. (In this case no snapshot file is created, as we don‚Äôt use the snapshot functionality)

[Paragraph 10] (49 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   Testing the stateWe can also easily test the state of our component. Update the component by initiating the state in the constructor and expanding the click event with the setState function. When clicking on the element, we‚Äôre now also going to update the clicked state from false to true.

[Paragraph 11] (36 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   Let‚Äôs create a third test where we render the output and check the state. The first time we check the clicked state property should be false. After a click the property should be changed to true.

[Paragraph 12] (45 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   The art of mockingOne of the best benefits of Jest is the easiness of creating all kind of mocks. We already usedjest.fn()in one of our unit tests which is a very simple mock function that returns a spy, but you can also mock entire files.

[Paragraph 13] (8 words)
   [DOM: p.oz.pa.ql.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: blockquote]
   If you aren‚Äôt mocking, you aren‚Äôt unit testing!

[Paragraph 14] (31 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   The most easiest way to mock files is using thejest.mockfunction which automatically mocks the file by returning mocked functions. Let try to mockreact-domand check whether the render function has been called.

[Paragraph 15] (41 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   We create the test like we normally would do, but added thejest.mockline. Now therenderfunction ofreact-domis a mock function which returns a spy which we can now use in our test to check whether it has been called with the correct properties.

[Paragraph 16] (59 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   When you don‚Äôt want Jest to automatically create mock functions of your file, you can easily create a mock file yourself. Just create a__mocks__ directory and add the to be mocked file in there. Now Jest will use this file when you calljest.mockin your unit test. For the react-dom example, create react-dom.js file which returns the render spy function.

[Paragraph 17] (26 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   In our example we‚Äôre returning a spy function on which we can check whether it‚Äôs called correctly, but you‚Äôre spy could also return values or implementations.

[Paragraph 18] (39 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   RoundupSo these are the very basics of unit testing your application using Jest and Enzyme. Both have very good online documentation available, start from here and you can create your unit tests in a fast, efficient and easy way!

[Paragraph 19] (9 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   There‚Äôs no reason to not start testing today ;)

[Paragraph 20] (29 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   Thank you for taking the time to reading this story! If you enjoyed reading this story, click the üëèüèª below so other people will see this here on Medium.

[Paragraph 21] (44 words)
   [DOM: p.pw-post-body-paragraph.oz.pa.jb.pb.b.pc.pd.pe.pf.pg.ph.pi.pj.hb.pk.pl.pm.he.pn.po.pp.hh.pq.pr.ps.pt.id.bl, parent: div]
   Also, I work atwehkamp.nlone of the biggest e-commerce companies of the Netherlands. We do have atech blog, check it out and subscribe if you want to read more stories like this one. Or look at ourjob offersif you are looking for a great job!

[Paragraph 22] (20 words)
   [DOM: p.bg.b.bh.ab.bl, parent: div]
   We'll try to keep up and post on the stuff we're doing and discovering. Interesting in working @wehkamp? Check outhttps://werkenbij.wehkamp.nl/
